import numpy as np
from Utils import Utils


class SampledGraph(object):
    """This class docstring shows general manipulating graph functions.

    Attributes:
        :param Graph graph: input object Graph.
        :param int number_of_nodes: integer of total number of graph nodes.
        :param float eval: float representing the largest graph's eigenvalue.
        :param dict p: dictionary object. key: nodes; values: probability proportional to graph degree.
        :param float alpha: float tunable parameter. It represents the contribution of the path to the
        importance of a pairwise of nodes. Used in computing Kats centrality.
    """

    def __init__(self, g, failure_probability=0.5, a=0):
        self.graph = g
        self.number_of_nodes = g.number_of_nodes()
        self.eval = Utils.largest_eigenvalue(g)
        self.p = failure_probability
        # self.p = Utils.failure_probability(g)
        self.alpha = a

    def get_graph(self):
        """Get the graph object.

        Returns:
            :returns: Returns the graph object.
            :rtype: Graph
        """
        return self.graph

    def get_eval(self):
        """Get the largest graph's eigenvalue parameter.

        Returns:
            :returns: Returns eval as the largest graph's eigenvalue parameter.
            :rtype: float
        """
        return self.eval

    def sample_nodes(self):
        """Get the dictionary of sampled nodes.

        Returns:
            :returns: d. Returns successful nodes chosen.
            key: random uniform selected graph nodes;
            values: successful nodes chosen according to p. NB: If it is true, the nodes will be removed.
            :rtype: dict
        """
        rand_sel = np.random.uniform(size=self.number_of_nodes)
		# if rand_sel > node robustness -> Successful attack: node removed
        if isinstance(self.p, float):
            nodes_to_sample = rand_sel > self.p
        elif isinstance(self.p, dict):
            nodes_to_sample = rand_sel > self.p.values()
        d = dict(zip(self.graph.nodes(), nodes_to_sample))
        return d

    def filter_nodes(self, list_of_sorted_nodes):
        """Get the list of nodes to remove. Only true nodes are accepted.

        Args:
            :param list list_of_sorted_nodes: List of nodes sorted with a certain criterion.

        Returns:
            :returns: result. Returns the nodes to delete.
            :rtype: list
        """
        result = []
        nodes_to_sample = self.sample_nodes()
        for node in list_of_sorted_nodes:
            if nodes_to_sample[node]:
                result.append(node)
        return result
