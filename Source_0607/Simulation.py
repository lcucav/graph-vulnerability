from SampledGraph import SampledGraph
import numpy as np


class Simulation(object):
    """This class docstring executes simulation procedure on examined graphs.

    Attributes:
        :param Graph graph_object: input object Graph.
    """
    def __init__(self, graph_object):
        self.graph_object = graph_object

    def get_graph_object(self):
        """Get the graph object.

        Returns:
            :returns: graph_object
            :rtype: Graph
        """
        return self.graph_object

    def get_sorted_nodes_list(self):
        """Get the list of nodes graph sorted according with a certain criterion.

        Returns:
            :returns: lsor. Returns lsor as list of sorted graph nodes invoking the appropriate
            SampledGraph's child class function.
            :rtype: list
        """
        lsor = self.graph_object.sorted_nodes_list()
        return lsor

    def simulate(self, list_of_sorted_nodes, number_of_trials=7):
        """Simulate the nodes deleting procedure.

        Args:
            :param list list_of_sorted_nodes: Fraction of list of nodes sorted with a certain criterion to delete.
            :param int number_of_trials: Number of trials in order to remove randomness.

        Returns:
            :returns: out. Returns out as the mean value of the largest graph's eigenvalue trials
            computed with the SampledGraph class function get_eval.
            :rtype: float
        """
        eval_list = []
        for trial in range(number_of_trials):
            graph_copy = self.graph_object.get_graph().copy()
            nodes_to_delete = self.graph_object.filter_nodes(list_of_sorted_nodes)
            graph_copy.remove_nodes_from(nodes_to_delete)
            eval_list.append(SampledGraph(graph_copy).get_eval())
            del graph_copy
        out = np.mean(np.array(eval_list))
        return out

    def run_simulation(self):
        """Starts the simulation in order to choose and delete a fraction of vital nodes.

        Returns:
            :returns: eval_list. Returns eval_list as the list largest graph's eigenvalue parameters
            after deleting a fraction of vital nodes.
            :rtype: list
        """
        list_of_sorted_nodes = self.get_sorted_nodes_list()
        number_of_nodes = self.graph_object.number_of_nodes
        node_fraction = map(int, list(0.02 * i * number_of_nodes for i in range(0, 10)))
        eval_list = []
        eval_0 = self.get_graph_object().get_eval()
        for number_of_nodes_to_delete in node_fraction:
            nodes_to_delete = list_of_sorted_nodes[:number_of_nodes_to_delete]
            largest_eig = self.simulate(nodes_to_delete, 7)
            eval_list.append(largest_eig / eval_0)
        return eval_list
